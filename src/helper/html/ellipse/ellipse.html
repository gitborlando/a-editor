<head></head>
<canvas id="canvas" style="border: 1px solid #ccc" width="500" height="500"></canvas>
<input id="$endD" type="range" min="0" max="360" value="0" /><span id="$endDV"></span>
<input id="$r" type="range" min="0" max="100" value="0" /><span id="$endDV">r</span>

<style>
  #canvas {
    width: 500px;
    height: 500px;
  }
</style>
<script>
  const ctx = canvas.getContext('2d')
  const d = (n) => (n * Math.PI) / 180

  let width = 200
  let height = 100
  let cx = width / 2
  let cy = height / 2
  let startD = d(0)
  let endD = d(360)
  let r = 0.5
  let tanSize = Math.sqrt(width ** 2 + height ** 2)

  $endD.oninput = (e) => {
    endD = d(+e.target.value)
    $endDV.innerText = `endD:${e.target.value}`
    render()
  }
  $r.oninput = (e) => {
    r = +e.target.value / 100
    render()
  }
  render()
  function render() {
    canvas.width = canvas.width
    ctx.strokeStyle = 'red'
    ctx.ellipse(cx, cy, cx, cy, d(0), startD, endD)
    ctx.fill()
    // ctx.save()
    // // ctx.translate(cx, cy)
    // ctx.lineTo(x, y)
    // ctx.restore()

    ctx.globalCompositeOperation = 'destination-out'
    ctx.beginPath()
    ctx.ellipse(cx, cy, cx * r, cy * r, d(0), endD, startD, true)
    ctx.closePath()

    // ctx.save()
    // ctx.translate(cx, cy)
    // ctx.rotate(endD)
    // ctx.moveTo(calculatePointOnEllipse(cx * r, cy * r, endD, cx, cy), 0)
    // ctx.lineTo(calculatePointOnEllipse(cx, cy, endD, cx, cy), 0)
    // ctx.restore()

    // ctx.closePath()
    ctx.fill()
  }

  function getEllipsePoint(a, b, theta) {
    const x = a * Math.cos(theta)
    const y = b * Math.sin(theta)
    return { x, y }
  }

  function calculatePointOnEllipse(a, b, theta, h, k) {
    // 计算极坐标上的距离 r
    const r = (a * b) / Math.sqrt(b ** 2 * Math.cos(theta) ** 2 + a ** 2 * Math.sin(theta) ** 2)
    console.log('r', r)
    return r
  }
</script>
